h2(#summary). Summary

Instrinsic object available in [[Bondi|Bondi Reference]]

h2(#description). Description

h2(#properties). Properties

- X509 := X509 certificate property used to create self signed X509 certs, open existing certs or sign data with a cert. See [[Crypto.X509]] for further details.

h3. Hash Properties

- MD5 := Evaluates to MD5 and has a HashSize property of 16
- SHA1 := Evaluates to SHA1 and has a HashSize property of 20
- SHA256 := Evaluates to SHA256 and has a HashSize property of 32
- SHA512 := Evaluates to SHA512 and has a HashSize property of 64

h3. Algorithm Properties

- AES := Evaluates to AES, has a KeySizes property of [16, 24, 32] and a BlockSize property of 16
- BLOWFISH := Evaluates to BLOWFISH, has a KeySizes property of [16, 32, 64, 128] and a BlockSize property of 8
- DES := Evaluates to DES, has a KeySizes property of ==[7]== and a BlockSize property of 8
- RC2 := Evaluates to RC2, has a KeySizes property of [16, 32, 64] and a BlockSize property of 8
- RC4 := Evaluates to RC4, has a KeySizes property of [16, 32, 64, 128, 256] and a BlockSize property of 1
- TripleDES := Evalutes to 3DES, has a KeySizes property of ==[21]== and a BlockSize property of 8

h2(#methods). Methods

- Decrypt(method, key, iv, data [, padding]) := Takes an encryption method (eg. "AES", "DES"), key, initialization vector, data to decrypt and optionally the padding mode (either "ZERO", "PKCS7", "ANSIX923" or "ISO10126"), returns decrypted data.
- DecryptAndVerify(method, key, iv, data [, padding]) := Takes an encryption method and hash (eg. "AES-MD5", "DES-SHA1"), key, initialization vector, data to decrypt and verify and optionally the padding mode (as above for Decrypt), returns decrypted and verified data.
- Encrypt(method, key, iv, data [, padding]) := Takes an encryption method (eg. "AES", "DES"), key, initialization vector, data to encrypt and optionally the padding mode (as above for Decrypt), returns encrypted data.
- EncryptAndSign(method, key, iv, data [, padding]) := Takes an encryption method and hash (eg. "AES-MD5", "DES-SHA1"), key, initialization vector, data to encrypt and sign and optionally the padding mode (as above for Decrypt), returns encrypted and signed data.
- Hash(method, data) := Takes a hash method (eg. "MD5", "SHA1") and data, returns a cryptographic hash value of the data.
- Hash(method, key, data) := Used for MAC (message authentication code) checking, takes a hash method (eg. "MD5", "SHA1"), key and data, returns a MAC (message authentication code) that can be used to compare.
- Key([data]) := Optionally takes data and returns a key that can be used in the encrypt and decrypt functions ensuring the correct size for the algorithm method used, if no data is provided a key generated with random data will be returned.
- Random (number of bytes) := Returns the request number of cryptographically random bytes.
- Sign(x509, data) := Takes an X509 certificate (from [[Crypto.X509]]) and data, returns a signature, only supports SHA1 as the digest currently.
- Verify(x509, data, signature) := Takes an X509 certificate (from [[Crypto.X509]]), data and signature, returns true if the signature is valid for the given X509 cert and data, false otherwise.

h2(#examples). Examples

```javascript
// A basic example of using Encrypt and Decrypt, showing how the IV can be passed along in the ciphertext bundle to use in decrypting on the other side.

var alg = Crypto.AES;
var key = Crypto.Key("the secret key");
var iv = Crypto.Random(alg.BlockSize);
var data = "The quick brown fox jumped over the lazy dog!";

var cipherText = Base64.Encode(iv + Crypto.Encrypt(alg, key, iv, data));
Response.Write("cipherText: " + cipherText + "\n");

var binaryData = Base64.Decode(cipherText);
var knownIV = binaryData.substr(0, alg.BlockSize);
var cryptedData = binaryData.substr(alg.BlockSize);
var plainText = Crypto.Decrypt(alg, key, knownIV, cryptedData);
Response.Write("plainText: " + plainText + "\n");

// Example of EncryptAndSign and DecryptAndVerify
var hash = Crypto.SHA1;
cipherText = Base64.Encode(iv + Crypto.EncryptAndSign(alg + "-" + hash, key, iv, data));
Response.Write("cipherText2: " + cipherText + "\n");

binaryData = Base64.Decode(cipherText);
knownIV = binaryData.substr(0, alg.BlockSize);
cryptedData = binaryData.substr(alg.BlockSize);
plainText = Crypto.DecryptAndVerify(alg + "-" + hash, key, knownIV, cryptedData);
Response.Write("plainText2: " + plainText + "\n");

// Use an invalid key in DecryptAndVerify
try {
        var invalidKey = Crypto.Key("");
        plainText = Crypto.DecryptAndVerify(alg + "-" + hash, invalidKey, knownIV, cryptedData);
} catch (e) {
        Response.Write(e + "\n");
}

// Use an invalid IV in DecryptAndVerify
try {
        var invalidIV = "";
        plainText = Crypto.DecryptAndVerify(alg + "-" + hash, key, invalidIV, cryptedData);
        Response.Write("plainText3: " + plainText);
} catch (e) {
        Response.Write(e + "\n");
}

// Hashing data
hash = Crypto.MD5;
var hashed = Crypto.Hash(hash, data);
Response.Write("Base64'd Hash: " + Base64.Encode(hashed) + "\n");

// Generating random crypto data
var rnd = Crypto.Random(10);
Response.Write("Random(10): " + Base64.Encode(rnd) + "\n");

// X509 Signing
var x509 = Crypto.X509.Create();
Response.Write("Created new X509 Cert:\n\
\tSubject: " + x509.Subject + "\n\
\tIssuer: " + x509.Issuer + "\n\
\tVersion: " + x509.Version + "\n\
\tSerial: " + x509.Serial + "\n\
\tSignature: " + x509.Signature + "\n\
\tNotBefore: " + x509.NotBefore + "\n\
\tNotAfter: " + x509.NotAfter + "\n");

var signature = Crypto.Sign(x509, data);
Response.Write("X509 Signature: " + Base64.Encode(signature) + "\n");

// X509 Verification
var valid = Crypto.Verify(x509, data, signature);
Response.Write("X509 Verified: " + valid + "\n");
```

h2(#seealso). See also

* [[Base64]]
* [[Crypto.X509]]